-- Turtle class for controlled mining

-- Helper variables
local FORWARD = 1
local RIGHT = 2
local BACKWARD = 3
local LEFT = 4
local UP = 5
local DOWN = 6

-- Tunnel map has structure like this
-- First index is y_depth
-- Then 4 digits which indicate how deep the corridors are (forward, right, backward, left)

local function Miner()
    -- Initialisation
    local miner = {}
    miner.idle = true
    miner.moving_home = false
    miner.find_tunnel_end = false
    miner.checking_vein = false
    miner.vein_path = {}
    miner.gps_pos = {gps.locate()}
    miner.home = vector.new(miner.gps_pos)
    miner.map = {0,0,0,0}
    miner.fuel_limit = turtle.getFuelLimit()
    miner.fuel = turtle.getFuelLevel()
    miner.forward_pos = 0
    miner.total_block_back = 0
    miner.depth = 35
    miner.tunnel_maps = {}
    miner.tunnel_maps[miner.depth] = miner.map
    miner.direction = nil
    miner.ticks = 0
    miner.MAX_TICKS = 40

    -- Main loop which is executed
    function miner.tick()
        miner.ticks = miner.ticks + 1
        if miner.ticks > miner.MAX_TICKS then
            miner.go_home()
        end
        -- Being idle
        if miner.idle then
            os.sleep(5)
            return
        end
        -- Going back home
        if miner.moving_home then
            miner.move_home()
            return
        end

        -- Check the depth of turtle
        if (miner.pos_y > miner.depth) then
            miner.dig_down()
        elseif miner.find_tunnel_end then
            -- Go to position of corridor
            miner.move_tunnel_end()
        else
            miner.strip_mine()
        end

        -- Finally we need to check if we need to go back home
        miner.check_fuel()

    end

    function miner.update_gps()
        miner.gps_pos = {gps.locate(1)}
        if miner.gps_pos[1] == nil then
            print("Failed to get gps position")
            return
        end
        miner.pos_y = miner.gps_pos[2]
        local position = vector.new(miner.gps_pos)
        miner.dist_home = position - miner.home
    end

    function miner.falling_block()
        local success, data = turtle.inspect()
        for key, value in pairs(config.falling_blocks) do
            if data.name == value then
                return true
            end
        end
        return false
    end

    function miner.dig_down()
        turtle.digDown()
        turtle.down()
        miner.pos_y = miner.pos_y - 1 -- Go down 1 depth
        miner.total_block_back = miner.total_block_back + 1
    end

    function miner.move_home()
        if miner.checking_vein then
            miner.strip_mine()
        elseif miner.forward_pos > 0 then
            turtle.back()
            miner.forward_pos = miner.forward_pos - 1
        elseif miner.pos_y < miner.home_y then
            turtle.up()
            miner.pos_y = miner.pos_y + 1
        else
            print("Miner going idle")
            miner.moving_home = false
            miner.idle = true
        end
        miner.total_block_back = miner.total_block_back - 1
    end

    function miner.move_forwards()
        -- Get rid of falling blocks in front of miner
        turtle.dig()
        while (miner.falling_block()) do
            turtle.dig()
            os.sleep(1)
        end
        turtle.forward()
        miner.total_block_back = miner.total_block_back + 1
        miner.map[miner.direction] = miner.map[miner.direction] + 1
        miner.checking_vein = true
    end


    function miner.strip_mine()
        -- Vein checking order is up,
        if miner.checking_vein then
            if not miner.moving_home then
                local success, data = turtle.inspectUp()
                if miner.check_vein(success, data) then
                    turtle.digUp()
                    turtle.up()
                    table.insert(miner.vein_path, UP)
                    return
                end
                local success, data = turtle.inspect()
                if miner.check_vein(success, data) then
                    turtle.dig()
                    turtle.forward()
                    table.insert(miner.vein_path, FORWARD)
                    return
                end
                turtle.turnLeft()
                local success, data = turtle.inspect()
                if miner.check_vein(success, data) then
                    turtle.dig()
                    turtle.forward()
                    table.insert(miner.vein_path, LEFT)
                    return
                end
                turtle.turnRight()
                turtle.turnRight()
                local success, data = turtle.inspect()
                if miner.check_vein(success, data) then
                    turtle.dig()
                    turtle.forward()
                    table.insert(miner.vein_path, RIGHT)
                    return
                end
                turtle.turnLeft()
                local success, data = turtle.inspectDown()
                if miner.check_vein(success, data) then
                    turtle.digDown()
                    turtle.down()
                    table.insert(miner.vein_path, DOWN)
                    return
                end
            end

            -- Move out of vein
            if #miner.vein_path > 0 then
                print("Vein path length: " .. #miner.vein_path)
                local action = miner.vein_path[#miner.vein_path]
                if action == FORWARD then
                    turtle.back()
                elseif action == LEFT then
                    turtle.back()
                    turtle.turnRight()
                elseif action == RIGHT then
                    turtle.back()
                    turtle.turnLeft()
                elseif action == DOWN then
                    turtle.up()
                elseif action == UP then
                    turtle.down()
                end
                table.remove(miner.vein_path)
            else
                miner.checking_vein = false
            end

        else
            miner.move_forwards()
        end
    end

    function miner.check_vein(success, data)
        if not success then
            return false
        end
        for i, name in pairs(config.ignore_blocks) do
            if string.find(data.name, name) then
                return false
            end
        end
        return true
    end

    function miner.move_tunnel_end()
        -- Find direction to move in
        if miner.direction == nil then
            miner.find_direction()
        end
        -- Move till tunnel end
        if miner.forward_pos < miner.map[miner.direction] then
            turtle.forward()
            miner.forward_pos = miner.forward_pos + 1
            miner.total_block_back = miner.total_block_back + 1
        else
            miner.find_tunnel_end = false
        end
    end

    -- Find direction to go in
    function miner.find_direction()
        local min = nil
        local dir = 1
        -- Find shortest direction to go in
        for i, item in pairs(miner.map) do
            if min == nil then
                min = item
            end
            if item < min then
                min = item
                dir = i
            end
        end
        miner.direction = dir
        print("Going in direction: " .. dir)
    end

    function miner.check_fuel()
        if turtle.getItemCount(1) > 2 then
            if miner.fuel < miner.total_block_back + 400 then
                turtle.refuel(1)
            end
        end
        if miner.fuel < miner.total_block_back + 100 then
            print("No fuel left, going home")
            miner.go_home()
        end
        -- Check for full inventory
        if turtle.getItemCount(16) ~= 0 then
            print("No inventory left, going home")
            miner.go_home()
        end
    end

    ---------------------------------------------
    -- Functions which can be called by remote --
    -- Can only start if gps is retrieved
    function miner.start()
        while miner.pos_y == nil do
            miner.update_gps()
            miner.home = vector.new(miner.gps_pos)
            miner.home_y = miner.pos_y
            print("Found gps position starting miner")
        end
        miner.idle = false
        miner.find_tunnel_end = true
        miner.vein_path = {}
        miner.checking_vein = false
    end

    function miner.go_home()
        miner.moving_home = true
    end

    function miner.set_depth(depth)
        miner.depth = depth
    end

    -------------------
    -- INFO FUNCTION --
    function miner.get_info()
        local info = {}
        miner.fuel = turtle.getFuelLevel()
        info.fuel = miner.fuel
        miner.tunnel_maps[miner.depth] = miner.map
        info.map = miner.map
        miner.update_gps()
        info.dist_home = miner.dist_home
        info.gps = miner.gps_pos
        miner.fuel_limit = turtle.getFuelLimit()
        if miner.gps_pos ~= nil then
            miner.pos_y = miner.gps_pos[2]
        end
        info.idle = miner.idle
        info.find_tunnel_end = miner.find_tunnel_end
        info.moving_home = miner.moving_home
        return info
    end

    return miner
end

function init()
    return Miner()
end
