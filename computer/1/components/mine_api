-- Turtle class for controlled mining

-- Helper variables
local FORWARD = 1
local UP = 2
local DOWN = 3
local LEFT = 4
local RIGHT = 5
local BACKWARD = 6

-- Tunnel map has structure like this
-- First index is y_depth
-- Then 4 digits which indicate how deep the corridors are (forward, right, backward, left)

local function Miner()
    -- Initialisation
    local miner = {}
    miner.idle = true
    miner.moving_home = false
    miner.find_tunnel_end = false
    miner.checking_vein = false
    miner.vein_path = {}
    miner.vein_table = {}
    miner.gps_pos = nil
    miner.home = nil
    miner.map = {0,0,0,0}
    miner.fuel_limit = turtle.getFuelLimit()
    miner.fuel = turtle.getFuelLevel()
    miner.forward_pos = 0
    miner.total_block_back = 0
    miner.depth = 25
    miner.tunnel_maps = {}
    miner.tunnel_maps[miner.depth] = miner.map
    miner.direction = nil

    -- Main loop which is executed
    function miner.tick()
        -- Being idle
        if miner.idle then
            os.sleep(5)
            return
        end
        -- Going back home
        if miner.moving_home then
            miner.move_home()
            return
        end

        -- Check the depth of turtle
        if (miner.pos_y > miner.depth) then
            miner.dig_down()
        elseif miner.find_tunnel_end then
            -- Go to position of corridor
            miner.move_tunnel_end()
        else
            miner.strip_mine()
        end

        -- Finally we need to check if we need to go back home
        miner.check_go_back()

    end

    function miner.update_gps()
        miner.gps_pos = {gps.locate(1)}
        if miner.gps_pos[1] == nil then
            print("Failed to get gps position")
            return
        end
        miner.pos_y = miner.gps_pos[2]
    end

    function miner.falling_block(inspect_fnc)
        local success, data = inspect_fnc()
        for key, value in pairs(config.falling_blocks) do
            if data.name == value then
                return true
            end
        end
        return false
    end

    function miner.dig_down()
        turtle.digDown()
        turtle.down()
        miner.pos_y = miner.pos_y - 1 -- Go down 1 depth
        miner.total_block_back = miner.total_block_back + 1
    end

    function miner.move_home()
        if miner.checking_vein then
            miner.strip_mine()
        elseif miner.forward_pos > 0 then
            turtle.back()
            miner.forward_pos = miner.forward_pos - 1
        elseif miner.pos_y < miner.home_y then
            turtle.up()
            miner.pos_y = miner.pos_y + 1
        else
            miner.empty_items()
            miner.moving_home = false
            miner.idle = true
        end
        miner.total_block_back = miner.total_block_back - 1
    end

    function miner.move_forwards()
        miner.forward()
        miner.forward_pos = miner.forward_pos + 1
        miner.total_block_back = miner.total_block_back + 1
        miner.map[miner.direction] = miner.map[miner.direction] + 1
        miner.checking_vein = true
    end

    function miner.forward()
        -- Get rid of falling blocks in front of miner
        turtle.dig()
        while (miner.falling_block(turtle.inspect)) do
            turtle.dig()
            os.sleep(1)
        end
        turtle.forward()
    end

    function miner.up()
        -- Get rid of falling blocks in front of miner
        turtle.digUp()
        while (miner.falling_block(turtle.inspectUp)) do
            turtle.digUp()
            os.sleep(1)
        end
        turtle.up()
    end


    function miner.strip_mine()
        -- Vein checking order is up,
        if miner.checking_vein then
            if miner.moving_home then
                miner.move_out_vein()
            else
                miner.mine_vein()
            end
        else
            miner.move_forwards()
        end
    end

    function miner.mine_vein()
        -- Haven't searched veins at this depth if table is still nil
        if miner.vein_table[#miner.vein_path] == nil then
            if miner.find_veins(FORWARD) then -- So first find veins
                return -- If found we return and continue checks
            end
            -- No vein found so we move out of vein
            miner.move_out_vein()
        else -- We already searched at this depth so continue search
            local action = miner.vein_table[#miner.vein_path]
            if miner.find_veins(action) then
                return
            else -- No new veins found so delete last element of vein table
                table.remove(miner.vein_table) -- Delete the table entry which held no veins
                miner.move_out_vein() -- Move out of vein with one step
            end
        end
    end

    function miner.vein_action(action)
        if action == FORWARD then
            miner.forward()
        elseif action == LEFT then
            miner.forward()
        elseif action == RIGHT then
            miner.forward()
        elseif action == DOWN then
            turtle.digDown()
            turtle.down()
        elseif action == UP then
            miner.up()
        end
        if miner.vein_table[#miner.vein_path] == nil then
            miner.vein_table[#miner.vein_path] = {}
        end
        miner.vein_table[#miner.vein_path] = action
        table.insert(miner.vein_path, action)
    end

    function miner.move_out_vein()
        -- Move out of vein
        if #miner.vein_path > 0 then
            print("Vein path length: " .. #miner.vein_path)
            local action = miner.vein_path[#miner.vein_path]
            if action == FORWARD then
                turtle.back()
            elseif action == LEFT then
                turtle.back()
                turtle.turnRight()
            elseif action == RIGHT then
                turtle.back()
                turtle.turnLeft()
            elseif action == DOWN then
                turtle.up()
            elseif action == UP then
                turtle.down()
            end
            table.remove(miner.vein_path)
        else
            miner.checking_vein = false
        end
    end

    function miner.find_veins(check_from)
        for i=check_from,5 do
            if i == 1 then
                if miner.check_vein(turtle.inspect) then
                    miner.vein_action(FORWARD)
                    return true
                end
            elseif i == 2 then
                if miner.check_vein(turtle.inspectUp) then
                    miner.vein_action(UP)
                    return true
                end
            elseif i == 3 then
                if miner.check_vein(turtle.inspectDown) then
                    miner.vein_action(DOWN)
                    return true
                end
            elseif i == 4 then
                turtle.turnLeft()
                if miner.check_vein(turtle.inspect) then
                    miner.vein_action(LEFT)
                    return true
                end
            elseif i == 5 then
                turtle.turnRight()
                if miner.check_vein(turtle.inspectUp) then
                    miner.vein_action(RIGHT)
                    return true
                end
            end
        end
        return false
    end

    function miner.check_vein(inspect_fnc)
        local success, data = inspect_fnc()
        if not success then
            return false
        end
        for i, name in pairs(config.ignore_blocks) do
            if string.find(data.name, name) then
                return false
            end
        end
        return true
    end

    function miner.move_tunnel_end()
        -- Find direction to move in
        if miner.direction == nil then
            miner.find_direction()
        end
        -- Move till tunnel end
        if miner.forward_pos < miner.map[miner.direction] then
            turtle.forward()
            miner.forward_pos = miner.forward_pos + 1
            miner.total_block_back = miner.total_block_back + 1
        else
            miner.find_tunnel_end = false
        end
    end

    -- Find direction to go in
    function miner.find_direction()
        local min = nil
        local dir = 1
        -- Find shortest direction to go in
        for i, item in pairs(miner.map) do
            if min == nil then
                min = item
            end
            if item < min then
                min = item
                dir = i
            end
        end
        miner.direction = dir
        print("Going in direction: " .. dir)
    end

    function miner.check_go_back()
        if turtle.getItemCount(1) > 2 then
            if miner.fuel < miner.total_block_back + 400 then
                turtle.refuel(1)
            end
        end
        if miner.fuel < miner.total_block_back + 100 then
            print("No fuel left, going home")
            miner.go_home()
        end
        -- Check for full inventory
        if turtle.getItemCount(16) ~= 0 then
            print("No inventory left, going home")
            miner.go_home()
        end
    end

    function miner.empty_items()
        -- Don't drop coal in inventory 0
        miner.full_turn()
        for i=2,16 do
            turtle.select(i)
            turtle.drop(64)
        end
        turtle.select(1)
        miner.full_turn()
    end

    function miner.full_turn()
        turtle.turnLeft()
        turtle.turnLeft()
    end

    ---------------------------------------------
    -- Functions which can be called by remote --
    -- Can only start if gps is retrieved
    function miner.start()
        while miner.pos_y == nil do
            miner.update_gps()
        end
        miner.home = vector.new(miner.gps_pos)
        miner.home_y = miner.pos_y
        miner.idle = false
        miner.find_tunnel_end = true
        miner.vein_path = {}
        miner.checking_vein = false
        miner.direction = nil
    end

    function miner.go_home()
        miner.moving_home = true
    end

    function miner.set_depth(depth)
        miner.depth = depth
    end

    -------------------
    -- INFO FUNCTION --
    function miner.get_info()
        local info = {}
        miner.fuel = turtle.getFuelLevel()
        info.fuel = miner.fuel
        miner.tunnel_maps[miner.depth] = miner.map
        info.map = miner.map
        miner.update_gps()
        info.gps = miner.gps_pos
        miner.fuel_limit = turtle.getFuelLimit()
        if miner.gps_pos ~= nil then
            miner.pos_y = miner.gps_pos[2]
        end
        info.idle = miner.idle
        info.find_tunnel_end = miner.find_tunnel_end
        info.moving_home = miner.moving_home
        info.checking_vein = miner.checking_vein
        info.total_block_back = miner.total_block_back
        return info
    end

    return miner
end

function init()
    return Miner()
end
